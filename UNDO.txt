Undo data is the information required to reverse the effects of DML statements. It used to be referred to as rollback but not any more. Whenever a transaction changes data, the preupdate version of the data is written out to an undo segment. 

The ACID test requires that the database must keep preupdate versions of the data in order that incomplete transactions can be reversed out, either automatically or via the ROLLBACK command. Secondly, for consistency the database must be able to present a query with a version of the database as it was at the time the query started [what if this query took 1 hour to run like?] - so the server process running the query will go to the undo segments and create a read consistent image of the blocks being queried if they were chanegd after the query started. 

From release 9i onwards, undo is also very powerful for flashback queries. This allows a user to see a past image of the database. For flashback queries, undo data is used to construct a version of one or more tables as they were at some stage previous by applying undo data. 

To query and ensure the database is using undo segments and not the older (rollback segments).

SYS @ sandpit > show parameter undo 
NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
undo_management                      string      AUTO
undo_retention                       integer     900
undo_tablespace                      string      UNDOTBS1


To see the current UNDO tablespace...
  1* select tablespace_name, contents, status from dba_tablespaces where contents = 'UNDO'
SYS @ sandpit > /
TABLESPACE_NAME                CONTENTS  STATUS
------------------------------ --------- ---------
UNDOTBS1                       UNDO      ONLINE



When a transaction starts, oracle will by default assign it to one and only one undo segment. Any one transaction can only be protected by one undo segment. This is not a problem as undo segments are not of a fixed size; so if a transaction does manage to fill an undo segment, oracle automatically adds on another extent to the segment so the transaction can continue. 

As a transaction updates tables or index data blocks, the informtaion needed to reverse back the transaction is written out to blocks of the assigned undo segment. All this happens in the database buffer cache. The fact that undo data information becomes inactive on commit means that the extents of undo segments can be used in a circular fashion. Eventually, the entire undo tablespace will have filled up with undo data, so when a new transaction starts, or a running transaction generates some more undo... the undo segment will wrap around and the the oldest inactive undo data within it will be overwritten. 

Errors related to UNDO:
The principles are simple; first there should always be enough undo space available to allow all transactions to continue and second, there should always be enough undo space to allow all queries to succeed. 

1 - If a transaction encounters ORA-30036 unable to extend segment in undo tablespace - then the statement that hit the problem will be rolled back, but the rest of the transaction remains intact and uncommited. This will only arise if the undo tablepsace is absolutely full of active undo data.
2 - if a query encounters a block that has been changed since the query started(in the database bufefr cache), then the server process will go to the undo segment to find the preupdate version of the data. if when it goes to the undo segment and finds that it has been overwritten - the query fails with the famous error ORA-1555 - snapshot too old. 

UNDO MANAGEMENT - should always be set to auto 
UNDO tablespace - nominates the tablespace which must have been created as an undo tablespace
UNDO_RETENTION - set in seconds is usually optional - it specifies a target for keeping unactive undo data and determines when it becomes expired. 

Where the undo_retention parameter is not optinal is if you have configured guarnteed undo retention.The default behaviour is for oracle to favour transactions succeeding over queries. Guarnteed undo retention , meaning undo data will never be overwritten until the time specified by the undo retention has passed, is enabled at tablespace level. The attribute can be specified at tablespace creation time. This would mean that all queries will complete successfully(if there finish within the undo_retention time). you will never have snapshot too old errors again - the downside is that transactions may fail due to lack of undo space. 

SIZING : Sizing the unod tablespace should be large enough to store the worst case of all undo generated by concurrent transactions, which means active undo (transactions) plus enough unexpired undo to satisfy the longest running queries. 

There is a view V$UNDOSTAT which will tell you all you need to know. 

To create an additional undo tablespace and swap between them - please see this quick tutorial:

SYS @ sandpit > create undo tablespace undo2
  2  datafile '/u02/oradata/sandpit/undo2tbs01.dbf'
  3  size 100M autoextend off
  4  retention guarantee;
Tablespace created.

SYS @ sandpit > column file_name format a40            
SYS @ sandpit > select file_name, tablespace_name from dba_data_files;
FILE_NAME                                TABLESPACE_NAME
---------------------------------------- ------------------------------
/u02/oradata/sandpit/users01.dbf         USERS
/u02/oradata/sandpit/undotbs01.dbf       UNDOTBS1
/u02/oradata/sandpit/sysaux01.dbf        SYSAUX
/u02/oradata/sandpit/system01.dbf        SYSTEM
/u02/oradata/sandpit/example01.dbf       EXAMPLE
/u02/oradata/sandpit/undo2tbs01.dbf      UNDO2

SYS @ sandpit > select status,contents, tablespace_name from dba_tablespaces;
STATUS    CONTENTS  TABLESPACE_NAME
--------- --------- ------------------------------
ONLINE    PERMANENT SYSTEM
ONLINE    PERMANENT SYSAUX
ONLINE    UNDO      UNDOTBS1
ONLINE    TEMPORARY TEMP
ONLINE    PERMANENT USERS
ONLINE    PERMANENT EXAMPLE
ONLINE    UNDO      UNDO2

SYS @ sandpit > alter system set undo_tablespace=UNDO2;
System altered.

SYS @ sandpit > show parameter undo;
NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
undo_management                      string      AUTO
undo_retention                       integer     900
undo_tablespace                      string      UNDO2
SYS @ sandpit >



